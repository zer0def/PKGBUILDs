From ed1b4c8812a5a785b957e47f541e80010ea17af0 Mon Sep 17 00:00:00 2001
From: zer0def <zer0def@zer0def.0>
Date: Tue, 25 Jun 2024 21:02:34 +0200
Subject: [PATCH] Yoink FFInputFormat header from FFmpeg 7.0

---
 src/video/avformat7-demux.h | 135 ++++++++++++++++++++++++++++++++++++
 src/video/cameradevice.cpp  |   5 +-
 2 files changed, 138 insertions(+), 2 deletions(-)
 create mode 100644 src/video/avformat7-demux.h

diff --git a/src/video/avformat7-demux.h b/src/video/avformat7-demux.h
new file mode 100644
index 0000000000..acce07ac46
--- /dev/null
+++ b/src/video/avformat7-demux.h
@@ -0,0 +1,135 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_DEMUX_H
+#define AVFORMAT_DEMUX_H
+
+#include <stdint.h>
+#include <libavformat/avformat.h>
+
+struct AVDeviceInfoList;
+
+/**
+ * For an FFInputFormat with this flag set read_close() needs to be called
+ * by the caller upon read_header() failure.
+ */
+#define FF_INFMT_FLAG_INIT_CLEANUP                             (1 << 0)
+
+typedef struct FFInputFormat {
+    /**
+     * The public AVInputFormat. See avformat.h for it.
+     */
+    AVInputFormat p;
+
+    /**
+     * Raw demuxers store their codec ID here.
+     */
+    enum AVCodecID raw_codec_id;
+
+    /**
+     * Size of private data so that it can be allocated in the wrapper.
+     */
+    int priv_data_size;
+
+    /**
+     * Internal flags. See FF_INFMT_FLAG_* above and FF_FMT_FLAG_* in internal.h.
+     */
+    int flags_internal;
+
+    /**
+     * Tell if a given file has a chance of being parsed as this format.
+     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
+     * big so you do not have to check for that unless you need more.
+     */
+    int (*read_probe)(const AVProbeData *);
+
+    /**
+     * Read the format header and initialize the AVFormatContext
+     * structure. Return 0 if OK. 'avformat_new_stream' should be
+     * called to create new streams.
+     */
+    int (*read_header)(struct AVFormatContext *);
+
+    /**
+     * Read one packet and put it in 'pkt'. pts and flags are also
+     * set. 'avformat_new_stream' can be called only if the flag
+     * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
+     * background thread).
+     * @return 0 on success, < 0 on error.
+     *         Upon returning an error, pkt must be unreferenced by the caller.
+     */
+    int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);
+
+    /**
+     * Close the stream. The AVFormatContext and AVStreams are not
+     * freed by this function
+     */
+    int (*read_close)(struct AVFormatContext *);
+
+    /**
+     * Seek to a given timestamp relative to the frames in
+     * stream component stream_index.
+     * @param stream_index Must not be -1.
+     * @param flags Selects which direction should be preferred if no exact
+     *              match is available.
+     * @return >= 0 on success (but not necessarily the new offset)
+     */
+    int (*read_seek)(struct AVFormatContext *,
+                     int stream_index, int64_t timestamp, int flags);
+
+    /**
+     * Get the next timestamp in stream[stream_index].time_base units.
+     * @return the timestamp or AV_NOPTS_VALUE if an error occurred
+     */
+    int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
+                              int64_t *pos, int64_t pos_limit);
+
+    /**
+     * Start/resume playing - only meaningful if using a network-based format
+     * (RTSP).
+     */
+    int (*read_play)(struct AVFormatContext *);
+
+    /**
+     * Pause playing - only meaningful if using a network-based format
+     * (RTSP).
+     */
+    int (*read_pause)(struct AVFormatContext *);
+
+    /**
+     * Seek to timestamp ts.
+     * Seeking will be done so that the point from which all active streams
+     * can be presented successfully will be closest to ts and within min/max_ts.
+     * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
+     */
+    int (*read_seek2)(struct AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
+
+    /**
+     * Returns device list with it properties.
+     * @see avdevice_list_devices() for more details.
+     */
+    int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);
+} FFInputFormat;
+
+static inline const FFInputFormat *ffifmt(const AVInputFormat *fmt)
+{
+    return (const FFInputFormat*)fmt;
+}
+#endif /* AVFORMAT_DEMUX_H */
diff --git a/src/video/cameradevice.cpp b/src/video/cameradevice.cpp
index f92997f586..a9a16e498e 100644
--- a/src/video/cameradevice.cpp
+++ b/src/video/cameradevice.cpp
@@ -26,6 +26,7 @@ extern "C" {
 #pragma GCC diagnostic ignored "-Wold-style-cast"
 #include <libavdevice/avdevice.h>
 #include <libavformat/avformat.h>
+#include "avformat7-demux.h"
 #pragma GCC diagnostic pop
 }
 #include "cameradevice.h"
@@ -299,8 +300,8 @@ QVector<QPair<QString, QString>> CameraDevice::getRawDeviceListGeneric()
     }
 
     s->iformat = iformat;
-    if (s->iformat->priv_data_size > 0) {
-        s->priv_data = av_mallocz(s->iformat->priv_data_size);
+    if (ffifmt(s->iformat)->priv_data_size > 0) {
+        s->priv_data = av_mallocz(ffifmt(s->iformat)->priv_data_size);
         if (!s->priv_data) {
             avformat_free_context(s);
             return devices;
